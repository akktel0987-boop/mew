local _0xA="Q6L6_PRIVATE_KEY_2025";
local function _0xB()
local _0xC=getgenv and getgenv()or_G;
if not _0xC then return false end;
return rawget(_0xC,string.char(95,75,69,89))
end;
local function _0xD()
while true do end
end;
if _0xB()~=_0xA then
task.spawn(function()
_0xD()
end);
return;
end;
pcall(function()
getgenv()[string.char(95,75,69,89)]=nil;
end);
task.spawn(function()
pcall(function()
script:Destroy();
end);
end);
local Players = game:GetService("Players")
local RunService = game:GetService("RunService") local UserInputService = game:GetService("UserInputService") local LocalPlayer = Players.LocalPlayer if not LocalPlayer then return end local PlayerGui = LocalPlayer:WaitForChild("PlayerGui") local Camera = workspace.CurrentCamera -- THEME / CONFIG local RED = Color3.fromRGB(160, 20, 30) -- dark red accent local DARK_BG = Color3.fromRGB(10, 10, 10) -- near black local PANEL_BG = Color3.fromRGB(22, 18, 18) -- panel background local INPUT_BG = Color3.fromRGB(40, 36, 36) -- input background local TEXT_COLOR = Color3.fromRGB(230, 230, 230) local HITBOX_MIN = 1 local DEFAULT_RESTORE_SHORT = 0.27 local HIT_DURATION = 0.4 local hitboxSize = 300 -- STATE local selectedTargets = {} -- [player] = true local selectedTorso = {} -- [player] = cached torso Part local origHRPSizes = {} -- [player] = Vector3 (original size) local espObjects = {} -- per-player esp storage local espEnabled = false local spectateTarget = nil local noclipEnabledLocal = false local noclipConn = nil local noclipCache = {} -- Restore tokens: activeRestoreIds[userId] = id (number) -- When a restore is scheduled for a player we set their id, and restore only if id still matches. local activeRestoreIds = {} local nextRestoreId = 0 -- UTIL local function safeDisconnect(conn) if conn and typeof(conn) == "RBXScriptConnection" then pcall(function() conn:Disconnect() end) end end local function findTorso(char) if not char then return nil end local names = {"HumanoidRootPart","UpperTorso","LowerTorso","Torso","Head"} for _,n in ipairs(names) do local p = char:FindFirstChild(n) if p and p:IsA("BasePart") then return p end end for _,v in ipairs(char:GetDescendants()) do if v:IsA("BasePart") then return v end end return nil end local function isAlive(pl) return pl and pl.Character and findTorso(pl.Character) and pl.Character:FindFirstChildWhichIsA("Humanoid") end local function cacheTorsoForPlayer(pl) if not pl then return end if pl.Character and pl.Character.Parent then local t = findTorso(pl.Character) selectedTorso[pl] = t if espObjects[pl] then if espObjects[pl].TorsoConn then safeDisconnect(espObjects[pl].TorsoConn); espObjects[pl].TorsoConn = nil end espObjects[pl].TorsoConn = pl.Character.ChildAdded:Connect(function(child) if child and child:IsA("BasePart") then task.wait(0.06) selectedTorso[pl] = findTorso(pl.Character) end end) end else selectedTorso[pl] = nil end end -- Immediate restore for a single player (called when we deselect or when player leaves) local function immediateRestoreForPlayer(pl) if not pl then return end -- cancel pending restore token activeRestoreIds[pl.UserId] = nil local orig = origHRPSizes[pl] if orig and pl.Character then local torso = selectedTorso[pl] or pl.Character:FindFirstChild("HumanoidRootPart") or findTorso(pl.Character) if torso and torso.Parent then pcall(function() torso.Size = orig torso.CanCollide = true end) end end origHRPSizes[pl] = nil end -- HITBOX apply/restore with per-player restore tokens local function applyHitboxToPlayers(playersArray, size, duration) if not playersArray or #playersArray == 0 then return end local targetsArr = {} for _, pl in ipairs(playersArray) do if pl and pl.Character then local torso = selectedTorso[pl] or pl.Character:FindFirstChild("HumanoidRootPart") or findTorso(pl.Character) if torso and torso.Parent then targetsArr[#targetsArr+1] = {pl = pl, torso = torso} selectedTorso[pl] = torso end end end if #targetsArr == 0 then return end -- cache original sizes for _, item in ipairs(targetsArr) do local pl = item.pl local torso = item.torso if torso and torso.Parent and not origHRPSizes[pl] then pcall(function() origHRPSizes[pl] = torso.Size end) end end -- create unique restore id for this application nextRestoreId = nextRestoreId + 1 local thisId = nextRestoreId -- mark activeRestoreIds for each player in this application for _, item in ipairs(targetsArr) do activeRestoreIds[item.pl.UserId] = thisId end local function applyList(list) for _, item in ipairs(list) do local torso = item.torso if torso and torso.Parent then pcall(function() torso.Size = Vector3.new(size, size, size) torso.CanCollide = false end) end end end local function restoreList(list, idToCheck) for _, item in ipairs(list) do local pl = item.pl if activeRestoreIds[pl.UserId] ~= idToCheck then -- skip if canceled or superseded; keep origHRPSizes until explicit restore else local torso = selectedTorso[pl] or (pl.Character and pl.Character:FindFirstChild("HumanoidRootPart")) or (pl.Character and findTorso(pl.Character)) if torso and torso.Parent then local orig = origHRPSizes[pl] pcall(function() if orig then torso.Size = orig end torso.CanCollide = true end) end origHRPSizes[pl] = nil activeRestoreIds[pl.UserId] = nil end end end if #targetsArr > 15 then local half = math.ceil(#targetsArr / 2) local first, second = {}, {} for i=1,#targetsArr do if i <= half then first[#first+1] = targetsArr[i] else second[#second+1] = targetsArr[i] end end applyList(first) delay(DEFAULT_RESTORE_SHORT, function() pcall(function() restoreList(first, thisId) end) end) RunService.Heartbeat:Wait() applyList(second) delay(DEFAULT_RESTORE_SHORT, function() pcall(function() restoreList(second, thisId) end) end) else applyList(targetsArr) delay(duration or HIT_DURATION, function() pcall(function() restoreList(targetsArr, thisId) end) end) end end -- Noclip: robust, do NOT raise torso on disable local function cacheParts(char) local cache = {} for _, part in ipairs(char:GetDescendants()) do if part:IsA("BasePart") then cache[part] = part.CanCollide end end return cache end local function setCollision(char, state) for _, part in ipairs(char:GetDescendants()) do if part:IsA("BasePart") then pcall(function() part.CanCollide = state end) end end end local function enableNoclipLocal() if noclipConn then safeDisconnect(noclipConn); noclipConn = nil end local ch = LocalPlayer.Character if not ch then return end noclipCache = cacheParts(ch) setCollision(ch, false) noclipConn = RunService.Stepped:Connect(function() local ch2 = LocalPlayer.Character if ch2 then for _, part in ipairs(ch2:GetDescendants()) do if part:IsA("BasePart") and part.CanCollide then pcall(function() part.CanCollide = false end) end end end end) noclipEnabledLocal = true end local function disableNoclipLocal() safeDisconnect(noclipConn); noclipConn = nil local ch = LocalPlayer.Character if ch then for part, val in pairs(noclipCache) do if part and part.Parent then pcall(function() part.CanCollide = val end) end end end noclipCache = {} noclipEnabledLocal = false end local function updateNoclipState() local any = false for _ in pairs(selectedTargets) do any = true; break end if any then if not noclipEnabledLocal then enableNoclipLocal() end else if noclipEnabledLocal then disableNoclipLocal() end end end -- ESP (red outlines) local function attachESPToCharacter(player, character) if not player or not character then return end espObjects[player] = espObjects[player] or {} local rec = espObjects[player] if rec.Billboard and rec.Billboard.Parent then pcall(function() rec.Billboard:Destroy() end) end if rec.HealthConn then safeDisconnect(rec.HealthConn); rec.HealthConn = nil end if rec.Highlight and rec.Highlight.Parent then pcall(function() rec.Highlight:Destroy() end) end if rec.CharConn then safeDisconnect(rec.CharConn); rec.CharConn = nil end local torso = findTorso(character) local hum = character:FindFirstChildWhichIsA("Humanoid") if not torso or not hum then rec.CharConn = player.CharacterAdded:Connect(function(ch) task.wait(0.12) if rec.enabled then attachESPToCharacter(player, ch) end end) return end selectedTorso[player] = torso local bb = Instance.new("BillboardGui") bb.Name = "VolodiESP" bb.Adornee = torso bb.AlwaysOnTop = true bb.Size = UDim2.new(0, 220, 0, 52) bb.StudsOffset = Vector3.new(0, -0.6, 0) bb.MaxDistance = 1400 bb.Parent = torso local container = Instance.new("Frame", bb) container.Size = UDim2.new(1, -8, 1, -8) container.Position = UDim2.new(0, 4, 0, 4) container.BackgroundTransparency = 1 local displayLabel = Instance.new("TextLabel", container) displayLabel.Size = UDim2.new(1, 0, 0, 20) displayLabel.Position = UDim2.new(0, 0, 0, 0) displayLabel.BackgroundTransparency = 1 displayLabel.Font = Enum.Font.GothamBold displayLabel.TextSize = 15 displayLabel.TextColor3 = TEXT_COLOR displayLabel.TextXAlignment = Enum.TextXAlignment.Center displayLabel.Text = tostring(player.DisplayName or player.Name) local userLabel = Instance.new("TextLabel", container) userLabel.Size = UDim2.new(1, 0, 0, 16) userLabel.Position = UDim2.new(0, 0, 0, 20) userLabel.BackgroundTransparency = 1 userLabel.Font = Enum.Font.Gotham userLabel.TextSize = 14 userLabel.TextColor3 = TEXT_COLOR userLabel.TextXAlignment = Enum.TextXAlignment.Center userLabel.Text = "@" .. tostring(player.Name) local hpLabel = Instance.new("TextLabel", container) hpLabel.Size = UDim2.new(1, 0, 0, 16) hpLabel.Position = UDim2.new(0, 0, 0, 36) hpLabel.BackgroundTransparency = 1 hpLabel.Font = Enum.Font.GothamBold hpLabel.TextSize = 13 hpLabel.TextColor3 = TEXT_COLOR hpLabel.TextXAlignment = Enum.TextXAlignment.Center hpLabel.Text = "HP: 0 / 0" pcall(function() if hum and hum.Parent then hpLabel.Text = string.format("HP: %d / %d", math.floor(hum.Health), math.floor(hum.MaxHealth or 100)) end end) rec.HealthConn = hum:GetPropertyChangedSignal("Health"):Connect(function() if hpLabel and hpLabel.Parent then pcall(function() hpLabel.Text = string.format("HP: %d / %d", math.floor(hum.Health), math.floor(hum.MaxHealth or 100)) end) end end) hum.Died:Connect(function() if hpLabel and hpLabel.Parent then pcall(function() hpLabel.Text = "HP: 0 / 0 (DEAD)" end) end end) local hl = Instance.new("Highlight") hl.Name = "VolodiHighlight" hl.Adornee = character hl.FillTransparency = 1 hl.OutlineColor = RED hl.OutlineTransparency = 0 hl.Parent = character rec.Billboard = bb rec.DisplayLbl = displayLabel rec.UserLbl = userLabel rec.HPLbl = hpLabel rec.Highlight = hl rec.CharConn = player.CharacterAdded:Connect(function(ch) task.wait(0.12) if rec.enabled then attachESPToCharacter(player, ch) end end) end local function ensureESPFor(player) if not player then return end espObjects[player] = espObjects[player] or {} espObjects[player].enabled = true if player.Character and player.Character.Parent then attachESPToCharacter(player, player.Character) else if not espObjects[player].CharConn then espObjects[player].CharConn = player.CharacterAdded:Connect(function(ch) task.wait(0.12) if espObjects[player].enabled then attachESPToCharacter(player, ch) end end) end end end local function removeESPFor(player) local rec = espObjects[player] if not rec then return end rec.enabled = false if rec.HealthConn then safeDisconnect(rec.HealthConn); rec.HealthConn = nil end if rec.Billboard and rec.Billboard.Parent then pcall(function() rec.Billboard:Destroy() end) end if rec.Highlight and rec.Highlight.Parent then pcall(function() rec.Highlight:Destroy() end) end if rec.TorsoConn then safeDisconnect(rec.TorsoConn); rec.TorsoConn = nil end selectedTorso[player] = nil end local function updateESPLabelFor(player) local rec = espObjects[player] if not rec or not rec.Billboard or not rec.Billboard.Parent then return end local hum = player.Character and player.Character:FindFirstChildWhichIsA("Humanoid") if rec.DisplayLbl then pcall(function() rec.DisplayLbl.Text = tostring(player.DisplayName or player.Name) end) end if rec.UserLbl then pcall(function() rec.UserLbl.Text = "@" .. tostring(player.Name) end) end if rec.HPLbl and hum and hum.Parent then pcall(function() rec.HPLbl.Text = string.format("HP: %d / %d", math.floor(hum.Health), math.floor(hum.MaxHealth or 100)) end) end end -- GUI (square, dark red theme) local screen = Instance.new("ScreenGui") screen.Name = "VolodiRedUI" screen.ResetOnSpawn = false screen.Parent = PlayerGui local main = Instance.new("Frame", screen) main.Name = "Main" main.Size = UDim2.new(0, 740, 0, 460) main.Position = UDim2.new(0, 16, 0, 16) main.BackgroundColor3 = DARK_BG main.BorderSizePixel = 0 main.Visible = false local header = Instance.new("Frame", main) header.Size = UDim2.new(1, 0, 0, 28) header.Position = UDim2.new(0, 0, 0, 0) header.BackgroundColor3 = PANEL_BG header.BorderSizePixel = 0 local headerTxt = Instance.new("TextLabel", header) headerTxt.Size = UDim2.new(1, -12, 1, 0) headerTxt.Position = UDim2.new(0, 8, 0, 0) headerTxt.BackgroundTransparency = 1 headerTxt.Font = Enum.Font.GothamBold headerTxt.TextSize = 14 headerTxt.TextColor3 = TEXT_COLOR headerTxt.Text = "" -- no header labels local leftCol = Instance.new("Frame", main) leftCol.Size = UDim2.new(0, 360, 1, -40) leftCol.Position = UDim2.new(0, 8, 0, 40) leftCol.BackgroundColor3 = PANEL_BG leftCol.BorderSizePixel = 0 local hbLabel = Instance.new("TextLabel", leftCol) hbLabel.Size = UDim2.new(1, -12, 0, 24); hbLabel.Position = UDim2.new(0, 6, 0, 6) hbLabel.BackgroundTransparency = 1; hbLabel.Font = Enum.Font.GothamBold; hbLabel.TextSize = 13; hbLabel.TextColor3 = TEXT_COLOR hbLabel.Text = "Hitbox (select players)" local sizeLabel = Instance.new("TextLabel", leftCol) sizeLabel.Size = UDim2.new(1, -12, 0, 20); sizeLabel.Position = UDim2.new(0, 6, 0, 34) sizeLabel.BackgroundTransparency = 1; sizeLabel.Font = Enum.Font.Gotham; sizeLabel.TextSize = 12; sizeLabel.TextColor3 = TEXT_COLOR sizeLabel.Text = "Size: " .. tostring(hitboxSize) local sizeInput = Instance.new("TextBox", leftCol) sizeInput.Size = UDim2.new(0.62, 0, 0, 28) sizeInput.Position = UDim2.new(0, 6, 0, 60) sizeInput.Text = tostring(hitboxSize) sizeInput.ClearTextOnFocus = false sizeInput.PlaceholderText = "Введите размер (число)" sizeInput.Font = Enum.Font.Gotham sizeInput.TextSize = 14 sizeInput.TextColor3 = TEXT_COLOR sizeInput.BackgroundColor3 = INPUT_BG sizeInput.BorderSizePixel = 0 local applyBtn = Instance.new("TextButton", leftCol) applyBtn.Size = UDim2.new(0.36, -6, 0, 28) applyBtn.Position = UDim2.new(0.64, 0, 0, 60) applyBtn.Text = "Apply" applyBtn.Font = Enum.Font.GothamBold applyBtn.TextSize = 14 applyBtn.BackgroundColor3 = RED applyBtn.TextColor3 = TEXT_COLOR applyBtn.BorderSizePixel = 0 local selectAllBtn = Instance.new("TextButton", leftCol) selectAllBtn.Size = UDim2.new(1, -12, 0, 28); selectAllBtn.Position = UDim2.new(0, 6, 0, 96) selectAllBtn.Text = "Select All"; selectAllBtn.Font = Enum.Font.GothamBold; selectAllBtn.TextSize = 13; selectAllBtn.BackgroundColor3 = DARK_BG; selectAllBtn.TextColor3 = TEXT_COLOR selectAllBtn.BorderSizePixel = 0 local selScroll = Instance.new("ScrollingFrame", leftCol) selScroll.Size = UDim2.new(1, -12, 1, -140); selScroll.Position = UDim2.new(0, 6, 0, 132) selScroll.BackgroundTransparency = 1; selScroll.BorderSizePixel = 0; selScroll.ScrollBarThickness = 8 local selLayout = Instance.new("UIListLayout", selScroll); selLayout.Padding = UDim.new(0, 6) local rightCol = Instance.new("Frame", main) rightCol.Size = UDim2.new(0, 360, 1, -40); rightCol.Position = UDim2.new(0, 372, 0, 40) rightCol.BackgroundColor3 = PANEL_BG rightCol.BorderSizePixel = 0 local espToggle = Instance.new("TextButton", rightCol) espToggle.Size = UDim2.new(0.48, -10, 0, 28); espToggle.Position = UDim2.new(0, 6, 0, 6) espToggle.Text = "Toggle ESP"; espToggle.Font = Enum.Font.GothamBold; espToggle.TextSize = 13; espToggle.BackgroundColor3 = DARK_BG; espToggle.TextColor3 = TEXT_COLOR espToggle.BorderSizePixel = 0 local specLabel = Instance.new("TextLabel", rightCol) specLabel.Size = UDim2.new(1, -12, 0, 24); specLabel.Position = UDim2.new(0, 6, 0, 40); specLabel.BackgroundTransparency = 1; specLabel.Font = Enum.Font.GothamBold; specLabel.TextSize = 13; specLabel.TextColor3 = TEXT_COLOR specLabel.Text = "Spectate (single select)" local specScroll = Instance.new("ScrollingFrame", rightCol) specScroll.Size = UDim2.new(1, -12, 1, -120); specScroll.Position = UDim2.new(0, 6, 0, 68) specScroll.BackgroundTransparency = 1; specScroll.BorderSizePixel = 0; specScroll.ScrollBarThickness = 8 local specLayout = Instance.new("UIListLayout", specScroll); specLayout.Padding = UDim.new(0, 6) local stopSpecBtn = Instance.new("TextButton", rightCol) stopSpecBtn.Size = UDim2.new(1, -12, 0, 28); stopSpecBtn.Position = UDim2.new(0, 6, 1, -40) stopSpecBtn.Text = "Stop Spectate"; stopSpecBtn.Font = Enum.Font.GothamBold; stopSpecBtn.TextSize = 13; stopSpecBtn.BackgroundColor3 = RED; stopSpecBtn.TextColor3 = TEXT_COLOR stopSpecBtn.BorderSizePixel = 0 -- helper to create rows (with subtle red stroke when selected) local function createRow(parent, player) local btn = Instance.new("TextButton", parent) btn.Size = UDim2.new(1, 0, 0, 36) btn.BackgroundColor3 = DARK_BG btn.AutoButtonColor = false btn.Text = "" btn.BorderSizePixel = 0 local leftLbl = Instance.new("TextLabel", btn) leftLbl.Size = UDim2.new(0.6, 0, 1, 0) leftLbl.Position = UDim2.new(0, 8, 0, 0) leftLbl.BackgroundTransparency = 1 leftLbl.Font = Enum.Font.GothamBold leftLbl.TextSize = 14 leftLbl.TextColor3 = TEXT_COLOR leftLbl.TextXAlignment = Enum.TextXAlignment.Left leftLbl.Text = tostring(player.DisplayName or player.Name) local rightLbl = Instance.new("TextLabel", btn) rightLbl.Size = UDim2.new(0.4, -12, 1, 0) rightLbl.Position = UDim2.new(0.6, 0, 0, 0) rightLbl.BackgroundTransparency = 1 rightLbl.Font = Enum.Font.Gotham rightLbl.TextSize = 13 rightLbl.TextColor3 = TEXT_COLOR rightLbl.TextXAlignment = Enum.TextXAlignment.Right rightLbl.Text = "@" .. tostring(player.Name) local stroke = Instance.new("UIStroke", btn) stroke.Color = RED stroke.Thickness = 2 stroke.Transparency = 1 -- hidden by default return btn, leftLbl, rightLbl, stroke end -- refresh lists local function refreshHitboxList() for _, c in ipairs(selScroll:GetChildren()) do if c:IsA("GuiObject") then c:Destroy() end end for _, pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer then local btn, l, r, stroke = createRow(selScroll, pl) if selectedTargets[pl] then btn.BackgroundColor3 = PANEL_BG; stroke.Transparency = 0 else btn.BackgroundColor3 = DARK_BG; stroke.Transparency = 1 end btn.MouseButton1Click:Connect(function() if selectedTargets[pl] then -- deselect: immediate restore & cleanup selectedTargets[pl] = nil selectedTorso[pl] = nil immediateRestoreForPlayer(pl) btn.BackgroundColor3 = DARK_BG stroke.Transparency = 1 else selectedTargets[pl] = true btn.BackgroundColor3 = PANEL_BG stroke.Transparency = 0 cacheTorsoForPlayer(pl) if espEnabled then ensureESPFor(pl) end end updateESPLabelFor(pl) updateNoclipState() end) end end selScroll.CanvasSize = UDim2.new(0, 0, 0, selLayout.AbsoluteContentSize.Y + 8) end local function refreshSpectateList() for _, c in ipairs(specScroll:GetChildren()) do if c:IsA("GuiObject") then c:Destroy() end end for _, pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer then local btn, l, r, stroke = createRow(specScroll, pl) stroke.Transparency = 1 btn.MouseButton1Click:Connect(function() for _, c in ipairs(specScroll:GetChildren()) do if c:IsA("GuiObject") then local s = c:FindFirstChildOfClass("UIStroke"); if s then s.Transparency = 1 end; c.BackgroundColor3 = DARK_BG end end stroke.Transparency = 0; btn.BackgroundColor3 = PANEL_BG if isAlive(pl) then spectateTarget = pl; Camera.CameraType = Enum.CameraType.Custom; Camera.CameraSubject = pl.Character:FindFirstChildWhichIsA("Humanoid") end end) end end specScroll.CanvasSize = UDim2.new(0, 0, 0, specLayout.AbsoluteContentSize.Y + 8) end -- select all / clear selectAllBtn.MouseButton1Click:Connect(function() local allSelected = true for _, pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer and not selectedTargets[pl] then allSelected = false; break end end if allSelected then -- clear: restore every selected player immediately for pl,_ in pairs(selectedTargets) do immediateRestoreForPlayer(pl) end selectedTargets = {} selectedTorso = {} else for _, pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer then selectedTargets[pl] = true cacheTorsoForPlayer(pl) if espEnabled then ensureESPFor(pl) end end end end refreshHitboxList() updateNoclipState() end) -- apply input handling (TextBox + Apply) local function applyHitboxValueFromInput() local text = sizeInput.Text and tostring(sizeInput.Text):gsub("%s+", "") or "" local n = tonumber(text) if n == nil then sizeInput.Text = tostring(hitboxSize) return false end n = math.floor(math.max(n, HITBOX_MIN)) hitboxSize = n sizeLabel.Text = "Size: " .. tostring(hitboxSize) sizeInput.Text = tostring(hitboxSize) return true end applyBtn.MouseButton1Click:Connect(function() applyHitboxValueFromInput() end) sizeInput.FocusLost:Connect(function() applyHitboxValueFromInput() end) espToggle.MouseButton1Click:Connect(function() if not espEnabled then espEnabled = true for _, pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer then ensureESPFor(pl) end end espToggle.BackgroundColor3 = RED else espEnabled = false for pl,_ in pairs(espObjects) do removeESPFor(pl) end espToggle.BackgroundColor3 = DARK_BG end end) stopSpecBtn.MouseButton1Click:Connect(function() spectateTarget = nil Camera.CameraType = Enum.CameraType.Custom Camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") for _, c in ipairs(specScroll:GetChildren()) do if c:IsA("GuiObject") then local s = c:FindFirstChildOfClass("UIStroke"); if s then s.Transparency = 1 end; c.BackgroundColor3 = DARK_BG end end end) local function clickOverGui() local pos = UserInputService:GetMouseLocation() local objs = PlayerGui:GetGuiObjectsAtPosition(pos.X, pos.Y) for _, o in ipairs(objs) do if o and o:IsDescendantOf(main) then return true end end return false end -- Activation key and batching trigger UserInputService.InputBegan:Connect(function(input, gameProcessed) if gameProcessed then return end if input.KeyCode == Enum.KeyCode.Home then main.Visible = not main.Visible return end if input.KeyCode == Enum.KeyCode.E then if main and main.Visible and clickOverGui() then return end -- collect alive selected players at time of press local toApply = {} for pl, _ in pairs(selectedTargets) do if isAlive(pl) then table.insert(toApply, pl) end end if #toApply > 0 then applyHitboxToPlayers(toApply, hitboxSize, HIT_DURATION) end end end) -- PlayerAdded / PlayerRemoving handlers Players.PlayerAdded:Connect(function(pl) espObjects[pl] = espObjects[pl] or {} cacheTorsoForPlayer(pl) refreshHitboxList() refreshSpectateList() if espEnabled then ensureESPFor(pl) end end) Players.PlayerRemoving:Connect(function(pl) -- immediate restore and cancel pending restores immediateRestoreForPlayer(pl) -- remove from selection/cache selectedTargets[pl] = nil selectedTorso[pl] = nil -- clean up ESP and connections if espObjects[pl] then if espObjects[pl].HealthConn then safeDisconnect(espObjects[pl].HealthConn) end if espObjects[pl].Billboard and espObjects[pl].Billboard.Parent then pcall(function() espObjects[pl].Billboard:Destroy() end) end if espObjects[pl].Highlight and espObjects[pl].Highlight.Parent then pcall(function() espObjects[pl].Highlight:Destroy() end) end if espObjects[pl].CharConn then safeDisconnect(espObjects[pl].CharConn) end if espObjects[pl].TorsoConn then safeDisconnect(espObjects[pl].TorsoConn) end espObjects[pl] = nil end -- stop spectating them if needed if spectateTarget == pl then spectateTarget = nil Camera.CameraType = Enum.CameraType.Custom Camera.CameraSubject = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") end -- update noclip state (will disable if nothing selected) updateNoclipState() -- refresh GUI lists so the row disappears refreshHitboxList() refreshSpectateList() end) -- Init for _, pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer then espObjects[pl] = espObjects[pl] or {} cacheTorsoForPlayer(pl) end end refreshHitboxList() refreshSpectateList() -- Drag header (square) local dragging = false local dragStart = Vector2.new() local startPos = UDim2.new() local moveConn = nil header.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true dragStart = UserInputService:GetMouseLocation() startPos = main.Position moveConn = UserInputService.InputChanged:Connect(function(inp) if not dragging then return end if inp.UserInputType == Enum.UserInputType.MouseMovement then local delta = UserInputService:GetMouseLocation() - dragStart local newX = startPos.X.Offset + delta.X local newY = startPos.Y.Offset + delta.Y local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280, 720) local absSize = main.AbsoluteSize newX = math.max(0, math.min(newX, math.max(0, vp.X - absSize.X))) newY = math.max(0, math.min(newY, math.max(0, vp.Y - absSize.Y))) main.Position = UDim2.new(0, newX, 0, newY) end end) end end) header.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false if moveConn then safeDisconnect(moveConn); moveConn = nil end end end) -- update noclip state on local respawn LocalPlayer.CharacterAdded:Connect(function() task.wait(0.15) updateNoclipState() end)
